package com.proxmox.firewall;

import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.databind.ObjectMapper;

@Service
@Transactional
public class FirewallServiceimpl {

	@Value("${proxmox.api.url}")
	private String proxmoxApiUrl;

	@Value("${proxmox.token.id}")
	private String tokenId;

	@Value("${proxmox.token.secret}")
	private String tokenSecret;

	@Autowired
	FirewallRepo firewallRepo;

	private AtomicLong idCounter = new AtomicLong(1000);

	public Long generateId() {
		return idCounter.incrementAndGet(); // Ensure this starts from a valid base
	}

	/*
	 * public Long generateId() { Long maxVmId = detailsRepo.findMaxVmId(); return
	 * maxVmId + 1; }
	 */

	public ResponseEntity<String> createfirewall(FirewallRule firewallDetails, Long vmId) {

		Long generatedId = generateId();
		firewallDetails.setVmid(generatedId);

		HttpHeaders headers = new HttpHeaders();
		headers.add("Authorization", "PVEAPIToken=" + tokenId + "=" + tokenSecret);
		headers.setContentType(MediaType.APPLICATION_JSON);

		// Construct the payload for creating a firewall rule
		Map<String, Object> payload = new HashMap<>();
//		payload.put("vmid",firewallDetails.getVmId());
		payload.put("action", firewallDetails.getAction());
		payload.put("node", firewallDetails.getNode());
		payload.put("type", firewallDetails.getType().name()); // Convert enum to string
		payload.put("source", firewallDetails.getSource());
		payload.put("proto", firewallDetails.getProto());
		payload.put("enable", firewallDetails.getEnable());

//		payload.put("macro", firewallDetails.getMacro());
		payload.put("iface", firewallDetails.getIface());
		payload.put("dest", firewallDetails.getDest());
		payload.put("dport", firewallDetails.getDport());
		payload.put("sport", firewallDetails.getSport());
		payload.put("comment", firewallDetails.getComment());

		
		// Serialize the payload to JSON
		ObjectMapper objectMapper = new ObjectMapper();
		String jsonPayload;
		try {
			jsonPayload = objectMapper.writeValueAsString(payload);
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body("Error serializing request body: " + e.getMessage());
		}

		headers.setContentLength(jsonPayload.getBytes(StandardCharsets.UTF_8).length);

		// Define the API endpoint for creating a firewall rule
		String url = String.format("%s/nodes/%s/qemu/%s/firewall/rules", proxmoxApiUrl, firewallDetails.getNode(),
				vmId);
		System.out.println("url = " + url);
		RestTemplate restTemplate = new RestTemplate();
		HttpEntity<String> request = new HttpEntity<>(jsonPayload, headers);

		try {
			// Make the API call to Proxmox to create the firewall rule
			ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);
			System.out.println("Response = " + response);

			// Check the response status and handle success or failure
			if (response.getStatusCode() == HttpStatus.OK || response.getStatusCode() == HttpStatus.CREATED) {
				// Save the firewall rule to the database (ID is auto-generated by JPA)
				firewallRepo.save(firewallDetails);
				return ResponseEntity.ok("Firewall  created successfully: " + response.getBody());
			} else {
				return ResponseEntity.status(response.getStatusCode()).body("Failed to create firewall rule. Status: "
						+ response.getStatusCode() + ", Body: " + response.getBody());
			}

		} catch (Exception e) {
			e.printStackTrace();
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error occurred: " + e.getMessage());
		}
	}
}